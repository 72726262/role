import 'package:flutter_bloc/flutter_bloc.dart';
import '../../services/database_service.dart';
import '../../models/hr_policy_model.dart';
import '../../models/training_course_model.dart';
import 'hr_dashboard_state.dart';

class HRDashboardCubit extends Cubit<HRDashboardState> {
  final DatabaseService _databaseService = DatabaseService();

  HRDashboardCubit() : super(HRDashboardInitial());

  Future<void> loadDashboard() async {
    emit(HRDashboardLoading());

    try {
      // Fetch all data in parallel
      final results = await Future.wait([
        _databaseService.getTotalEmployeesCount(),
        _databaseService.getMoodStatistics(),
        _databaseService.getHRPolicies(),
        _databaseService.getTrainingCourses(),
      ]);

      final totalEmployees = results[0] as int;
      final moodStats = results[1] as Map<String, int>;
      final policies = results[2] as List;
      final courses = results[3] as List;

      emit(HRDashboardLoaded(
        totalEmployees: totalEmployees,
        moodStats: moodStats,
        policies: policies.cast(),
        courses: courses.cast(),
      ));
    } catch (e) {
      emit(HRDashboardError(e.toString()));
    }
  }

  Future<void> refresh() async {
    await loadDashboard();
  }
}

class HRPolicyCubit extends Cubit<HRPolicyState> {
  final DatabaseService _databaseService = DatabaseService();

  HRPolicyCubit() : super(HRPolicyInitial());

  Future<void> loadPolicies() async {
    emit(HRPolicyLoading());

    try {
      final policies = await _databaseService.getHRPolicies();
      emit(HRPolicyLoaded(policies));
    } catch (e) {
      emit(HRPolicyError(e.toString()));
    }
  }

  Future<void> createPolicy({
    required String title,
    required String description,
    String? pdfUrl,
    String? category,
  }) async {
    try {
      final policy = HRPolicyModel(
        id: '', // Will be generated by Supabase
        title: title,
        description: description,
        pdfUrl: pdfUrl,
        category: category,
        isActive: true,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );
      await _databaseService.createHRPolicy(policy);
      emit(const HRPolicySuccess('Policy created successfully'));
      await loadPolicies();
    } catch (e) {
      emit(HRPolicyError(e.toString()));
    }
  }

  Future<void> updatePolicy({
    required String id,
    required String title,
    required String description,
    String? pdfUrl,
    String? category,
  }) async {
    try {
      final policy = HRPolicyModel(
        id: id,
        title: title,
        description: description,
        pdfUrl: pdfUrl,
        category: category,
        isActive: true,
        createdAt: DateTime.now(), // Will be preserved by DB
        updatedAt: DateTime.now(),
      );
      await _databaseService.updateHRPolicy(policy);
      emit(const HRPolicySuccess('Policy updated successfully'));
      await loadPolicies();
    } catch (e) {
      emit(HRPolicyError(e.toString()));
    }
  }

  Future<void> deletePolicy(String id) async {
    try {
      await _databaseService.deleteHRPolicy(id);
      emit(const HRPolicySuccess('Policy deleted successfully'));
      await loadPolicies();
    } catch (e) {
      emit(HRPolicyError(e.toString()));
    }
  }
}

class TrainingCourseCubit extends Cubit<TrainingCourseState> {
  final DatabaseService _databaseService = DatabaseService();

  TrainingCourseCubit() : super(TrainingCourseInitial());

  Future<void> loadCourses() async {
    emit(TrainingCourseLoading());

    try {
      final courses = await _databaseService.getTrainingCourses();
      emit(TrainingCourseLoaded(courses));
    } catch (e) {
      emit(TrainingCourseError(e.toString()));
    }
  }

  Future<void> createCourse({
    required String title,
    required String description,
    int? durationHours,
    String? instructor,
    DateTime? startDate,
    DateTime? endDate,
    int? maxParticipants,
  }) async {
    try {
      final course = TrainingCourseModel(
        id: '', // Will be generated by Supabase
        title: title,
        description: description,
        durationHours: durationHours,
        instructor: instructor,
        startDate: startDate,
        endDate: endDate,
        maxParticipants: maxParticipants,
        isActive: true,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );
      await _databaseService.createTrainingCourse(course);
      emit(const TrainingCourseSuccess('Course created successfully'));
      await loadCourses();
    } catch (e) {
      emit(TrainingCourseError(e.toString()));
    }
  }

  Future<void> updateCourse({
    required String id,
    required String title,
    required String description,
    int? durationHours,
    String? instructor,
    DateTime? startDate,
    DateTime? endDate,
    int? maxParticipants,
  }) async {
    try {
      final course = TrainingCourseModel(
        id: id,
        title: title,
        description: description,
        durationHours: durationHours,
        instructor: instructor,
        startDate: startDate,
        endDate: endDate,
        maxParticipants: maxParticipants,
        isActive: true,
        createdAt: DateTime.now(), // Will be preserved by DB
        updatedAt: DateTime.now(),
      );
      await _databaseService.updateTrainingCourse(course);
      emit(const TrainingCourseSuccess('Course updated successfully'));
      await loadCourses();
    } catch (e) {
      emit(TrainingCourseError(e.toString()));
    }
  }

  Future<void> deleteCourse(String id) async {
    try {
      await _databaseService.deleteTrainingCourse(id);
      emit(const TrainingCourseSuccess('Course deleted successfully'));
      await loadCourses();
    } catch (e) {
      emit(TrainingCourseError(e.toString()));
    }
  }
}
